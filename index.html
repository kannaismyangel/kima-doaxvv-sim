<script src="https://unpkg.com/vue@3"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.4/gsap.min.js"></script>
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css"> -->
<!-- <script src="https://cdn.tailwindcss.com"></script> -->
<script src="https://cdn.plot.ly/plotly-2.12.1.min.js"></script>
<div id="app">
  <h1>Setup:</h1>
  <label>Tickets: </label>
  <input v-model="input.tickets" :disabled=simulationInProgress> @
  <select v-model="input.ticketRatio" :disabled=simulationInProgress>
    <option v-for="option in ratioOptions" :value="option.value" :disabled="option.disabled">
      {{ option.text }}
    </option>
  </select>
  <br>
  <label>Free stones: </label>
  <input v-model="input.freeStones" :disabled=simulationInProgress> ({{freeRolls}} rolls) @
  <select v-model="input.freeRatio" :disabled=simulationInProgress>
    <option v-for="option in ratioOptions" :value="option.value" :disabled="option.disabled">
      {{ option.text }}
    </option>
  </select>
  <br>
  <label>Paid Stones: </label>
  <input v-model="input.paidStones" :disabled=simulationInProgress> ({{paidRolls}} rolls) @
  <select v-model="input.paidRatio" :disabled=simulationInProgress>
    <option v-for="option in ratioOptions" :value="option.value" :disabled="option.disabled">
      {{ option.text }}
    </option>
  </select>
  <br>
  
  <h2>Banner</h2>
  <label>Target girls:</label>
  <input type="number" v-model="input.bannerTarget" min="1" :max="input.bannerTotal" :disabled=simulationInProgress>
  /
  <input type="number" v-model="input.bannerTotal" :min=input.bannerTarget :max="MAX_GIRLS" :disabled=simulationInProgress> in banner
  <br>

  <label>Roll until...</label>
  <input type="radio" id="one" value="one-copy" v-model="input.rollUntil" :disabled=simulationInProgress>
  <label for="one">Every target girl has a copy</label>

  <input type="radio" id="awaken" value="awaken" v-model="input.rollUntil" :disabled=simulationInProgress>
  <label for="two">Every target girl is Max Awakened (5 copies)</label>

  <input type="radio" id="all" value="all" v-model="input.rollUntil" :disabled=simulationInProgress>
  <label for="two">Out of stones</label>

  <br>
  Simulate<span v-if="!cleared"> again</span>:
  <button @click="simulate(1)">Once</button>
  <button @click="simulate(100)">100x</button>
  <button @click="simulate(1000)">1000x</button>
  <button @click="simulate(10000)">10000x</button>
  <button @click="stopSimulation">Stop</button>
  <button @click="clearSimData">Clear</button>

  <h1>Current simulation (#{{sim.id}}):</h1>
  Status: {{sim.status}} 
  <span v-if="sim.status == 'SUCCESS'">ü•∞</span>
  <span v-else-if="sim.status == 'FAILED'">üò¢</span>
  <br>
  Rolls: {{sim.rolls}} (remaining {{sim.remaining.tickets}} / {{sim.remaining.free}} / {{sim.remaining.paid}})
  <ul>
    <li v-for="girl in activeGirls" :key="girl.id">
      <girl :value="girl"></girl>
    </li>
  </ul>

  Sim Statistics:
  <ul>
    <li>Total SSRs: {{summary.totalSSRs}} ({{summary.SSRRatio}} %)</li>
    <li>Target SSRs: {{summary.targetSSRs}} (with {{summary.extraTargetSSRs}} extra)</li>
    <li>Non-target SSRs: {{summary.nonTargetSSRs}} (with {{summary.extraNonTargetSSRs}} extra)</li>
  </ul>

  <h1>Overall statistics</h1>
  <ul>
    <li> {{statistics.simulationCount}} simulations
    <li> Number of failures: {{statistics.failures}} 
      ({{(statistics.failures / statistics.simulationCount * 100).toFixed(2)}} %) </li>
    <li> <span style='color:blue'>Average rolls to succeed: {{statistics.meanRolls}}</span></li>
    <li> <span style='color:green'>Median rolls to succeed: {{statistics.medRolls}}</span> </li> 
    <li><span style='color:blue'>Average number of SSRs: {{statistics.meanSSRs}}</span></li>
    <li><span style='color:green'>Median number of SSRs: {{statistics.medSSRs}}</span></li>
  </ul>
  <div id="piechart"></div>
  <div id="histogram"></div>
  <div id="ssrhistogram"></div>

</div>
<script type="module">
  const { createApp } = Vue
  const gworker = new Worker("./gacha-worker.js");
  gworker.onmessage = function(e) {
    let data = e.data;
    switch (data.state) {
      case 'simResult':
        console.log("got simResult");
        vue.handleSimulationResult(data.result)
        break;
      case 'simulationComplete':
        console.log("got simulationComplete");
        vue.handleSimulationComplete();
        break;
    };
  };

  let vue = createApp({
    created() {
      for (let i = 0; i < this.MAX_GIRLS; i++) {
        this.girls.push({
          id:i,
          name: "girl" + i,
          gets: 0,
          target: i + 1 <= this.input.bannerTarget
        })
      }
    },
    data() {
      return {
        MAX_GIRLS: 26,
        input: {
          tickets: 600,
          freeStones: 1000000,
          paidStones: 10000,
          bannerTotal: 7,
          bannerTarget: 3,
          rollUntil:"awaken",
          ticketRatio:"all11",
          freeRatio:"every3rd",
          paidRatio:"all33",
        },

        girls: [],

        cleared: true,
        simulationInProgress: false,

        ratioOptions: [
          {text:"Select SSR chance", value:'', disabled:true},
          {text:"1.1% every roll", value:"all11", disabled:false},
          {text:"3.3% every roll", value:"all33", disabled:false},
          {text:"1.1% with every 3rd role at 3.3%", value:"every3rd", disabled:false},
          {text:"1.1% with every 6th role at 3.3%", value:"every6th", disabled:false},
        ],

        sim: {
          id: 0,
          status: '???',
          rolls: 0,
          remaining: {
            tickets: 0,
            free: 0,
            paid: 0,
          }
        },

        statistics: {
          simulationCount: 0,
          failures: 0,
          requiredRolls: [],
          meanRolls: 0,
          medRolls: 0,
          ssrs: [],
          meanSSRs: 0,
          medSSRs: 0,
        }
      }
    },
    computed: {
      freeRolls() { return this.input.freeStones/500; },
      paidRolls() { return this.input.paidStones/500; },
      desiredCopies() {
        switch(this.input.rollUntil) {
          case 'awaken':
            return 5;
          case 'one-copy':
            return 1;
          default:
            return -1;
        }
      },
      activeGirls() {
        return this.girls.slice(0, this.input.bannerTotal);
      },
      summary() {
        let stats = {
          totalSSRs: 0,
          SSRRatio: 0,
          targetSSRs: 0,
          extraTargetSSRs: 0,
          nonTargetSSRs: 0,
          extraNonTargetSSRs: 0,
        }
        this.activeGirls.forEach(girl => {
          stats.totalSSRs += girl.ssrs;
          if (girl.target) {
            stats.targetSSRs += girl.ssrs;
            if (this.input.rollUntil == "awaken" && girl.ssrs >= 5) {
              stats.extraTargetSSRs += girl.ssrs - 5;
            } else if (this.input.rollUntil == "one-copy" && girl.ssrs >= 1) {
              stats.extraTargetSSRs += girl.ssrs - 1;
            }
          } else {
            stats.nonTargetSSRs += girl.ssrs;
            if (this.input.rollUntil == "awaken" && girl.ssrs >= 5) {
              stats.extraNonTargetSSRs += girl.ssrs - 5;
            } else if (this.input.rollUntil == "one-copy" && girl.ssrs >= 1) {
              stats.extraNonTargetSSRs += girl.ssrs - 1;
            }
          }
        });
        stats.SSRRatio = (stats.totalSSRs / this.sim.rolls * 100).toFixed(2);
        return stats;
      },
    },
    methods: {
      simulate(times) {
        if (this.cleared && !this.simulationInProgress) {
          this.cleared = false;
          gworker.postMessage({
            action:"setup", 
            params:{
              ticketRolls: this.input.tickets,
              ticketRatio: this.input.ticketRatio,
              freeRolls: this.freeRolls,
              freeRatio: this.input.freeRatio,
              paidRolls: this.paidRolls,
              paidRatio: this.input.paidRatio,
              totalGirls: this.input.bannerTotal,
              mainGirls: this.input.bannerTarget,
              desiredCopies: this.desiredCopies,
            }
          });
        }
        this.simulationInProgress = true;
        gworker.postMessage({
          action:"simulate", 
          params:{times:times}
        });
      },
      stopSimulation() {
        this.simulationInProgress = false;
        gworker.postMessage({
          action:"stop", 
        });
        this.renderChart();
      },
      handleSimulationComplete() {
        this.simulationInProgress = false;
        this.renderChart();
      },
      handleSimulationResult(result) {
        console.log(JSON.stringify(result));
        for (let i = 0; i < result.girls.length; i++) {
          this.girls[i].ssrs = result.girls[i];
        }
       
        this.sim.id = result.id;
        this.sim.status = result.success ? "SUCCESS" : "FAILED";
        this.sim.rolls = result.rollCount;

        let remainingRolls = this.sim.rolls;
        let remaining = {}
        if (remainingRolls > 0) {
          let diff = Math.min(remainingRolls, this.input.tickets);
          remainingRolls -= diff;
          remaining.tickets = this.input.tickets - diff;
        }
        if (remainingRolls > 0) {
          let diff = Math.min(remainingRolls, this.freeRolls);
          remainingRolls -= diff;
          remaining.free = this.freeRolls - diff;
        }
        remaining.paid = this.paidRolls - remainingRolls;
        this.sim.remaining = remaining;

        this.statistics.simulationCount++;
        if (result.success) {
          this.statistics.requiredRolls.push(this.sim.rolls);
        } else {
          this.statistics.failures++;
        }
        this.statistics.ssrs.push(this.summary.totalSSRs);
      },
      renderChart() {
        this.renderRollHistogram();
        this.renderSuccessPie();
        this.renderSSRHistogram();
      },
      renderRollHistogram() {
        let rolls = this.statistics.requiredRolls;
        if (rolls.length > 0) {
          let sum = rolls.reduce((a,b) => a+b,0);
          this.statistics.meanRolls = (sum / rolls.length).toFixed(0);
          this.statistics.medRolls = rolls.sort()[(rolls.length/2).toFixed(0)];
        }
        let data = {
          x: this.statistics.requiredRolls,
          type: 'histogram',
          histnorm: 'percent',
          marker: { color: 'red' },
          opacity: 0.5,
        };

        var layout = {
          bargap: 0.05, 
          bargroupgap: 0.2, 
          barmode: "overlay", 
          title: "Number of rolls to " + this.input.rollUntil, 
          xaxis: {title: "Rolls"}, 
          yaxis: {title: "% of Simulations"},
          shapes: [{
            name: 'average',
            type: 'line',
            xref: 'x',
            yref: 'paper',
            x0: this.statistics.meanRolls,
            y0: 0,
            x1: this.statistics.meanRolls,
            y1: 1,
            line: {
              color: 'blue',
              width: 3
            }
          },{
            name: 'median',
            type: 'line',
            xref: 'x',
            yref: 'paper',
            x0: this.statistics.medRolls,
            y0: 0,
            x1: this.statistics.medRolls,
            y1: 1,
            line: {
              color: 'green',
              width: 3
            }
          }]
        };
        Plotly.newPlot('histogram', [data], layout);
      }, 
      renderSSRHistogram() {
        let ssrs = this.statistics.ssrs;
        if (ssrs.length > 0) {
          let sum = ssrs.reduce((a,b) => a+b,0);
          this.statistics.meanSSRs = (sum / ssrs.length).toFixed(0);
          this.statistics.medSSRs = ssrs.sort()[(ssrs.length/2).toFixed(0)];
        }
        let data = {
          x: this.statistics.ssrs,
          type: 'histogram',
          histnorm: 'percent',
          marker: { color: 'lightblue' },
          opacity: 0.5,
        };

        var layout = {
          bargap: 0.05, 
          bargroupgap: 0.2, 
          barmode: "overlay", 
          title: "SSR's probability", 
          xaxis: {title: "SSRs"}, 
          yaxis: {title: "% of Simulations"},
          shapes: [{
            name: 'average',
            type: 'line',
            xref: 'x',
            yref: 'paper',
            x0: this.statistics.meanSSRs,
            y0: 0,
            x1: this.statistics.meanSSRs,
            y1: 1,
            line: {
              color: 'blue',
              width: 3
            }
          },{
            name: 'median',
            type: 'line',
            xref: 'x',
            yref: 'paper',
            x0: this.statistics.medSSRs,
            y0: 0,
            x1: this.statistics.medSSRs,
            y1: 1,
            line: {
              color: 'green',
              width: 3
            }
          }]
        };
        Plotly.newPlot('ssrhistogram', [data], layout);
      },
      renderSuccessPie() {
        var pieData = [{
          values: [ this.statistics.simulationCount - this.statistics.failures,this.statistics.failures],
          labels: ['Success','Failure'],
          type: 'pie'
        }];
        Plotly.newPlot('piechart', pieData);
      },
      clearSimData() {
        this.cleared = true;
        this.sim = {
          id: 0,
          status: '???',
          rolls: 0,
          remaining: {
            tickets: 0,
            free: 0,
            paid: 0,
          }
        };

        this.statistics= {
          simulationCount: 0,
          failures: 0,
          requiredRolls: [],
          meanRolls: 0,
          medRolls: 0,
          ssrs: [],
          meanSSRs: 0,
          medSSRs: 0,
        };
        for (let girl of this.girls) {
          girl.ssrs = 0;
        }

        Plotly.purge('histogram');
        Plotly.purge('piechart');
        Plotly.purge('ssrhistogram');
      }
    },
    watch: {
      input: {
        handler() {
          console.log("INPUT!!");
          this.clearSimData();
        },
        deep: true,
      },
      'input.bannerTarget'() {
        for (let i = 0; i < this.MAX_GIRLS; i++) {
          this.girls[i].target = i + 1 <= this.input.bannerTarget;
        }
      },
    },
    components: {
      "animate-integer":{
        props: ["value"],
        watch: {
          value() {
            gsap.to(this, { duration: 0.5, animatedValue: Number(this.value) || 0 })
          },
        },
        data() {
          return {
            animatedValue: this.value
          };
        },
        template:`{{ animatedValue.toFixed(0) }}`
      },
      "girl":{
        props: ["value"],
        data() {
          return {
            data: this.value
          };
        },
        template:`
        <span v-if="data.target" style="color:red">
          ‚ù§{{ data.name }}‚ù§
        </span>
        <span v-else>
          {{ data.name }}
        </span>
        <span v-if="data.ssrs >= 5" style="font-weight:bold">
          (MAX)
        </span>
        :<span v-for="index in data.ssrs">
          <span v-if="index == 1">‚òÖ</span>
          <span v-else-if="index < 5">‚òÜ</span>
          <span v-else-if="index == 5">‚ú™</span>
          <span v-else>‚öπ</span>
        </span>
        `
      }
    }
  }).mount('#app')
</script>
